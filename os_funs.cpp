#include "MingOS.h"
using namespace std;

//函数实现
void Ready()	//登录系统前的准备工作,变量初始化+注册+安装
{
	//初始化变量
	nextUID = 0;
	nextGID = 0;
	isLogin = false;
	strcpy(Cur_User_Name,"root");//当前用户名
	strcpy(Cur_Group_Name,"root");//当前用户组

	//获取主机名
	memset(Cur_Host_Name,0,sizeof(Cur_Host_Name));  //获取主机名
	DWORD k= 100;  
	GetComputerName(Cur_Host_Name,&k);

	//根目录inode地址 ，当前目录地址和名字
	Root_Dir_Addr = Inode_StartAddr;	//第一个inode地址
	Cur_Dir_Addr = Root_Dir_Addr;//当前的目录地址Root
	strcpy(Cur_Dir_Name,"/");//当前目录名字


	char c;
	printf("是否格式化?[y/n]");
	while(c = getch()){
		fflush(stdin);
		if(c=='y'){
			printf("\n");
			printf("文件系统正在格式化……\n");
			if(!Format()){//将文件系统格式化
				printf("文件系统格式化失败\n");
				return ;
			}
			printf("格式化完成\n");
			break;
		}
		else if(c=='n'){//不格式化
			printf("\n");
			break;
		}
	}

	//printf("载入文件系统……\n");
	if(!Install()){			//安装文件系统
		printf("安装文件系统失败\n");
		return ;
	}
	//printf("载入完成\n");
}

bool Format()	//格式化一个虚拟磁盘文件
{
	int i,j;

	//初始化超级块
	superblock->s_INODE_NUM = INODE_NUM;//inode数量
	superblock->s_BLOCK_NUM = BLOCK_NUM;//块数量
	superblock->s_SUPERBLOCK_SIZE = sizeof(SuperBlock);//超级块大小
	superblock->s_INODE_SIZE = INODE_SIZE;//inode大小
	superblock->s_BLOCK_SIZE = BLOCK_SIZE;//块大小
	superblock->s_free_INODE_NUM = INODE_NUM;//空闲inode数量
	superblock->s_free_BLOCK_NUM = BLOCK_NUM;//空闲块数量
	superblock->s_blocks_per_group = BLOCKS_PER_GROUP;//每组块数
	superblock->s_free_addr = Block_StartAddr;	//空闲块堆栈指针为第一块block
	superblock->s_Superblock_StartAddr = Superblock_StartAddr;//超级块地址
	superblock->s_BlockBitmap_StartAddr = BlockBitmap_StartAddr;//块位图地址
	superblock->s_InodeBitmap_StartAddr = InodeBitmap_StartAddr;//inode位图地址
	superblock->s_Block_StartAddr = Block_StartAddr;//块地址
	superblock->s_Inode_StartAddr = Inode_StartAddr;//inode地址
	//空闲块堆栈在后面赋值

	//初始化inode位图
	memset(inode_bitmap,0,sizeof(inode_bitmap));//inode位图的值全部设置为0
	fseek(fw,InodeBitmap_StartAddr,SEEK_SET);//L确定位置开始写入
	fwrite(inode_bitmap,sizeof(inode_bitmap),1,fw);//L写入函数

	//初始化block位图
	memset(block_bitmap,0,sizeof(block_bitmap));//block位图的值全部设置为0
	fseek(fw,BlockBitmap_StartAddr,SEEK_SET);//L确定位置开始写入
	fwrite(block_bitmap,sizeof(block_bitmap),1,fw);//L写入函数
	
	//初始化磁盘块区，根据成组链接法组织	
	for(i=BLOCK_NUM/BLOCKS_PER_GROUP-1;i>=0;i--){	//一共INODE_NUM/BLOCKS_PER_GROUP组，一组FREESTACKNUM（128）个磁盘块 ，第一个磁盘块作为索引
		if(i==BLOCK_NUM/BLOCKS_PER_GROUP-1)
			superblock->s_free[0] = -1;	//没有下一个空闲块了
		else
			superblock->s_free[0] = Block_StartAddr + (i+1)*BLOCKS_PER_GROUP*BLOCK_SIZE;	//指向下一个空闲块
		for(j=1;j<BLOCKS_PER_GROUP;j++){
			superblock->s_free[j] = Block_StartAddr + (i*BLOCKS_PER_GROUP + j)*BLOCK_SIZE;//指向下一个空闲块
		}
		fseek(fw,Block_StartAddr+i*BLOCKS_PER_GROUP*BLOCK_SIZE,SEEK_SET);//L确定位置开始写入
		fwrite(superblock->s_free,sizeof(superblock->s_free),1,fw);	//填满这个磁盘块，512字节
	}
	//超级块写入到虚拟磁盘文件
	fseek(fw,Superblock_StartAddr,SEEK_SET);//L确定位置开始写入
	fwrite(superblock,sizeof(SuperBlock),1,fw);//L写入函数

	fflush(fw);//刷新缓冲区

	//读取inode位图
	fseek(fr,InodeBitmap_StartAddr,SEEK_SET);//L确定位置开始读取
	fread(inode_bitmap,sizeof(inode_bitmap),1,fr);//L读取函数

	//读取block位图
	fseek(fr,BlockBitmap_StartAddr,SEEK_SET);//	L确定位置开始读取
	fread(block_bitmap,sizeof(block_bitmap),1,fr);//L读取函数

	fflush(fr);//刷新缓冲区

	//创建根目录 "/"
		Inode cur;

		//申请inode
		int inoAddr = ialloc(); //L分配i节点区函数，返回inode地址

		//给这个inode申请磁盘块
		int blockAddr = balloc();//L磁盘块分配函数

		//在这个磁盘块里加入一个条目 "."
		DirItem dirlist[16] = {0};//L初始化一个空目录
		strcpy(dirlist[0].itemName,".");
		dirlist[0].inodeAddr = inoAddr;//L设置inode地址

		//写回磁盘块
		fseek(fw,blockAddr,SEEK_SET);	//L确定位置开始写入
		fwrite(dirlist,sizeof(dirlist),1,fw);//L写入函数

		//给inode赋值
		cur.i_ino = 0;//L设置inode号
		cur.i_atime = time(NULL);//L设置文件打开最后访问时间
		cur.i_ctime = time(NULL);//L设置inode最后修改时间
		cur.i_mtime = time(NULL);//L设置文件内容最后修改时间
		strcpy(cur.i_uname,Cur_User_Name);//L设置用户名
		strcpy(cur.i_gname,Cur_Group_Name);//L设置用户组名
		cur.i_cnt = 1;	//一个项，当前目录,"."
		cur.i_dirBlock[0] = blockAddr;//L设置第一个目录块地址
		for(i=1;i<10;i++){
			cur.i_dirBlock[i] = -1;
		}
		cur.i_size = superblock->s_BLOCK_SIZE;//L设置文件大小
		cur.i_indirBlock_1 = -1;	//没使用一级间接块
		cur.i_mode = MODE_DIR | DIR_DEF_PERMISSION;//L设置文件权限


		//写回inode
		fseek(fw,inoAddr,SEEK_SET);	//L确定位置开始写入
		fwrite(&cur,sizeof(Inode),1,fw);//L写入函数
		fflush(fw);//刷新缓冲区

	//创建目录及配置文件
	mkdir(Root_Dir_Addr,"home");	//用户目录//创建目录
	cd(Root_Dir_Addr,"home");//进入当前目录下的name目录
	mkdir(Cur_Dir_Addr,"root");		//L目录创建函数。参数：上一层目录文件inode地址 ,要创建的目录名
	//用户的密码和账户 以及管理员的一个账户密码都存储在/etc/passwd文件中 用于登录时的存取以及后续管理的管理查看等等	
	cd(Cur_Dir_Addr,"..");//返回上一层目录
	mkdir(Cur_Dir_Addr,"etc");	//配置文件目录
	cd(Cur_Dir_Addr,"etc");//进入当前目录下的name目录

	char buf[1000] = {0};//L初始化一个空缓冲区
	
	sprintf(buf,"root:x:%d:%d\n",nextUID++,nextGID++);	//增加条目，用户名：加密密码：用户ID：用户组ID
	create(Cur_Dir_Addr,"passwd",buf);	//创建用户信息文件

	sprintf(buf,"root:root\n");	//增加条目，用户名：密码
	create(Cur_Dir_Addr,"shadow",buf);	//创建用户密码文件
	chmod(Cur_Dir_Addr,"shadow",0660);	//修改权限，禁止其它用户读取该文件

	sprintf(buf,"root::0:root\n");	//增加管理员用户组，用户组名：口令（一般为空，这里没有使用）：组标识号：组内用户列表（用，分隔）
	sprintf(buf+strlen(buf),"user::1:\n");	//增加普通用户组，组内用户列表为空
	create(Cur_Dir_Addr,"group",buf);	//创建用户组信息文件

	cd(Cur_Dir_Addr,"..");	//回到根目录

	return true;
}

bool Install()	//安装文件系统，将虚拟磁盘文件中的关键信息如超级块读入到内存
{
	//读写虚拟磁盘文件，读取超级块，读取inode位图，block位图，读取主目录，读取etc目录，读取管理员admin目录，读取用户xiao目录，读取用户passwd文件。

	//读取超级块
	fseek(fr,Superblock_StartAddr,SEEK_SET);//fseek的作用是设置文件指针的位置，SEEK_SET表示从文件开头开始
	fread(superblock,sizeof(SuperBlock),1,fr);//fread的作用是从文件中读取数据，读取一个数据块

	//读取inode位图
	fseek(fr,InodeBitmap_StartAddr,SEEK_SET);//fseek的作用是设置文件指针的位置，SEEK_SET表示从文件开头开始
	fread(inode_bitmap,sizeof(inode_bitmap),1,fr);//fread的作用是从文件中读取数据，读取的数据存放在第一个参数指向中

	//读取block位图
	fseek(fr,BlockBitmap_StartAddr,SEEK_SET);//fseek的作用是设置文件指针的位置，SEEK_SET表示从文件开头开始
	fread(block_bitmap,sizeof(block_bitmap),1,fr);//fread的作用是从文件中读取数据，读取的数据存放在第一个参数指向中

	return true;
}

void printSuperBlock()		//打印超级块信息
{
	printf("\n");
	printf("空闲inode数 / 总inode数 ：%d / %d\n",superblock->s_free_INODE_NUM,superblock->s_INODE_NUM);//空闲inode数 / 总inode数
	printf("空闲block数 / 总block数 ：%d / %d\n",superblock->s_free_BLOCK_NUM,superblock->s_BLOCK_NUM);//空闲block数 / 总block数
	printf("本系统 block大小：%d 字节，每个inode占 %d 字节（真实大小：%d 字节）\n",superblock->s_BLOCK_SIZE,superblock->s_INODE_SIZE,sizeof(Inode));//本系统 block大小：block大小，每个inode占 inode大小（真实大小：inode大小）
	printf("\t每磁盘块组（空闲堆栈）包含的block数量：%d\n",superblock->s_blocks_per_group);//每磁盘块组（空闲堆栈）包含的block数量
	printf("\t超级块占 %d 字节（真实大小：%d 字节）\n",superblock->s_BLOCK_SIZE,superblock->s_SUPERBLOCK_SIZE);//超级块占 block大小（真实大小：超级块大小）
	printf("磁盘分布：\n");
	printf("\t超级块开始位置：%d B\n",superblock->s_Superblock_StartAddr);//超级块开始位置
	printf("\tinode位图开始位置：%d B\n",superblock->s_InodeBitmap_StartAddr);//inode位图开始位置
	printf("\tblock位图开始位置：%d B\n",superblock->s_BlockBitmap_StartAddr);//block位图开始位置
	printf("\tinode区开始位置：%d B\n",superblock->s_Inode_StartAddr);//inode区开始位置
	printf("\tblock区开始位置：%d B\n",superblock->s_Block_StartAddr);//
	printf("\n");

	return ;
}

void printInodeBitmap()	//打印inode使用情况
{
	printf("\n");
	printf("inode使用表：[uesd:%d %d/%d]\n",superblock->s_INODE_NUM-superblock->s_free_INODE_NUM,superblock->s_free_INODE_NUM,superblock->s_INODE_NUM);//inode使用表：[uesd:inode数-空闲inode数/inode数]
	int i;
	i = 0;
	printf("0 ");
	while(i<superblock->s_INODE_NUM){//打印inode使用情况
		if(inode_bitmap[i])//inode使用
			printf("*");
		else
			printf(".");
		i++;
		if(i!=0 && i%32==0){
			printf("\n");
			if(i!=superblock->s_INODE_NUM)//如果i!=inode数，则打印空格
				printf("%d ",i/32);
		}
	}
	printf("\n");
	printf("\n");
	return ;
}

void printBlockBitmap(int num)	//打印block使用情况
{
	printf("\n");
	printf("block（磁盘块）使用表：[used:%d %d/%d]\n",superblock->s_BLOCK_NUM-superblock->s_free_BLOCK_NUM,superblock->s_free_BLOCK_NUM,superblock->s_BLOCK_NUM);//block（磁盘块）使用表：[used:block数-空闲block数/block数]
	int i;
	i = 0;
	printf("0 ");
	while(i<num){
		if(block_bitmap[i])//block使用
			printf("*");
		else
			printf(".");
		i++;
		if(i!=0 && i%32==0){
			printf("\n");
			if(num==superblock->s_BLOCK_NUM)//如果num=block数，则打印空格//!这里存在getchar并且持续的读取
				getchar();
			if(i!=superblock->s_BLOCK_NUM)//如果i!=block数，则打印i/32
				printf("%d ",i/32);
		}
	}
	printf("\n");
	printf("\n");
	return ;
}

int balloc()	//磁盘块分配函数
{
	//参照成组链接法如何读取使用空闲块的方式去进行分配
	//使用超级块中的空闲块堆栈
	//计算当前栈顶
	int top;	//栈顶指针
	if(superblock->s_free_BLOCK_NUM==0){	//剩余空闲块数为0//如果超级块中现实的剩余空闲块数为零，则返回-1
		printf("没有空闲块可以分配\n");
		return -1;	//没有可分配的空闲块，返回-1
	}
	else{	//还有剩余块//分配栈顶指针的位置
		top = (superblock->s_free_BLOCK_NUM-1) % superblock->s_blocks_per_group;
	}
	//将栈顶取出
	//如果已是栈底，将当前块号地址返回，即为栈底块号，并将栈底指向的新空闲块堆栈覆盖原来的栈
	int retAddr;
	//下面是还有空闲块的情况，具体是如何分配的
	if(top==0){
		retAddr = superblock->s_free_addr;//返回栈顶的地址
		superblock->s_free_addr = superblock->s_free[0];	//取出下一个存有空闲块堆栈的空闲块的位置，更新空闲块堆栈指针
		
		//取出对应空闲块内容，覆盖原来的空闲块堆栈

		//取出下一个空闲块堆栈，覆盖原来的
		fseek(fr,superblock->s_free_addr,SEEK_SET);
		fread(superblock->s_free,sizeof(superblock->s_free),1,fr);
		fflush(fr);

		superblock->s_free_BLOCK_NUM--;//更新超级块中空闲块数

	}
	else{	//如果不为栈底，则将栈顶指向的地址返回，栈顶指针-1.
		retAddr = superblock->s_free[top];	//保存返回地址
		superblock->s_free[top] = -1;	//清栈顶
		top--;		//栈顶指针-1
		superblock->s_free_BLOCK_NUM--;	//空闲块数-1

	}

	//更新超级块
	fseek(fw,Superblock_StartAddr,SEEK_SET);//将文件指针移动到超级块的位置
	fwrite(superblock,sizeof(SuperBlock),1,fw);//将超级块写入文件
	fflush(fw);//将缓冲区内容写入文件

	//更新block位图
	block_bitmap[(retAddr-Block_StartAddr)/BLOCK_SIZE] = 1;
	fseek(fw,(retAddr-Block_StartAddr)/BLOCK_SIZE+BlockBitmap_StartAddr,SEEK_SET);	//(retAddr-Block_StartAddr)/BLOCK_SIZE为第几个空闲块
	fwrite(&block_bitmap[(retAddr-Block_StartAddr)/BLOCK_SIZE],sizeof(bool),1,fw);//将空闲块位图写入文件
	fflush(fw);//将缓冲区内容写入文件

	return retAddr;

}

bool bfree(int addr)	//磁盘块释放函数
{
	//判断
	//该地址不是磁盘块的起始地址
	if( (addr-Block_StartAddr) % superblock->s_BLOCK_SIZE != 0 ){
		printf("地址错误,该位置不是block（磁盘块）起始位置\n");
		return false;
	}
	unsigned int bno = (addr-Block_StartAddr) / superblock->s_BLOCK_SIZE;	//inode节点号
	//该地址还未使用，不能释放空间
	if(block_bitmap[bno]==0){
		printf("该block（磁盘块）还未使用，无法释放\n");//该地址还未使用，不能释放空间
		return false;
	}	
	//以下时可以释放磁盘块的情况，一样是成组链接法的一个操作
	//可以释放
	//计算当前栈顶
	int top;	//栈顶指针
	if(superblock->s_free_BLOCK_NUM==superblock->s_BLOCK_NUM){	//没有非空闲的磁盘块
		printf("没有非空闲的磁盘块，无法释放\n");
		return false;	//没有可分配的空闲块，返回-1
	}
	else{	//非满
		top = (superblock->s_free_BLOCK_NUM-1) % superblock->s_blocks_per_group;
					
		//清空block内容
		char tmp[BLOCK_SIZE] = {0};
		fseek(fw,addr,SEEK_SET);	
		fwrite(tmp,sizeof(tmp),1,fw);

		if(top == superblock->s_blocks_per_group-1){	//该栈已满

			//该空闲块作为新的空闲块堆栈
			superblock->s_free[0] = superblock->s_free_addr;	//新的空闲块堆栈第一个地址指向旧的空闲块堆栈指针接到空余块的链接里面
			int i;
			for(i=1;i<superblock->s_blocks_per_group;i++){
				superblock->s_free[i] = -1;	//清空栈元素的其它地址
			}
			fseek(fw,addr,SEEK_SET);//将文件指针移动到空闲块堆栈的起始地址
			fwrite(superblock->s_free,sizeof(superblock->s_free),1,fw);	//填满这个磁盘块，512字节
			
		}
		else{	//栈还未满
			top++;	//栈顶指针+1
			superblock->s_free[top] = addr;	//栈顶放上这个要释放的地址，作为新的空闲块
		}
	}
	

	//更新超级块
	superblock->s_free_BLOCK_NUM++;	//空闲块数+1
	fseek(fw,Superblock_StartAddr,SEEK_SET);//将文件指针移动到超级块的位置
	fwrite(superblock,sizeof(SuperBlock),1,fw);//将超级块写入文件

	//更新block位图
	block_bitmap[bno] = 0;
	fseek(fw,bno+BlockBitmap_StartAddr,SEEK_SET);	//(addr-Block_StartAddr)/BLOCK_SIZE为第几个空闲块
	fwrite(&block_bitmap[bno],sizeof(bool),1,fw);//将空闲块位图写入文件
	fflush(fw);//将缓冲区内容写入文件

	return true;
}

int ialloc()	//分配i节点区函数，返回inode地址
{
	//在inode位图中顺序查找空闲的inode，找到则返回inode地址。函数结束。
	if(superblock->s_free_INODE_NUM==0){
		printf("没有空闲inode可以分配\n");
		return -1;
	}
	else{//L顺序的查找到空闲的inode返回并且进行分配的同时去更新超级块以及inode位图
			
		//顺序查找空闲的inode
		int i;
		for(i=0;i<superblock->s_INODE_NUM;i++){
			if(inode_bitmap[i]==0)	//找到空闲inode
				break;
		}


		//更新超级块
		superblock->s_free_INODE_NUM--;	//空闲inode数-1
		fseek(fw,Superblock_StartAddr,SEEK_SET);
		fwrite(superblock,sizeof(SuperBlock),1,fw);

		//更新inode位图
		inode_bitmap[i] = 1;
		fseek(fw,InodeBitmap_StartAddr+i,SEEK_SET);	
		fwrite(&inode_bitmap[i],sizeof(bool),1,fw);
		fflush(fw);

		return Inode_StartAddr + i*superblock->s_INODE_SIZE;
	}
}

bool ifree(int addr)	//释放i结点区函数
{
	//判断 如果提供的地址错误 返回
	if( (addr-Inode_StartAddr) % superblock->s_INODE_SIZE != 0 ){
		printf("地址错误,该位置不是i节点起始位置\n");
		return false;
	}
	unsigned short ino = (addr-Inode_StartAddr) / superblock->s_INODE_SIZE;	//inode节点号
	if(inode_bitmap[ino]==0){//如果该inode还没有释放则不需要进行释放的一个操作
		printf("该inode还未使用，无法释放\n");
		return false;
	}	
	
	//清空inode内容
	Inode tmp = {0};
	fseek(fw,addr,SEEK_SET);	//将文件指针移动到inode的起始地址
	fwrite(&tmp,sizeof(tmp),1,fw);//将inode内容清空

	//更新超级块
	superblock->s_free_INODE_NUM++;	//空闲inode数+1
	//空闲inode数+1
	fseek(fw,Superblock_StartAddr,SEEK_SET);//	将文件指针移动到超级块的起始地址
	fwrite(superblock,sizeof(SuperBlock),1,fw);//将超级块写入文件

	//更新inode位图
	inode_bitmap[ino] = 0;
	fseek(fw,InodeBitmap_StartAddr+ino,SEEK_SET);	//	将文件指针移动到inode位图的起始地址
	fwrite(&inode_bitmap[ino],sizeof(bool),1,fw);//将inode位图写入文件
	fflush(fw);//将缓冲区内容写入文件

	return true;
}

bool mkdir(int parinoAddr,char name[])	//目录创建函数。参数：上一层目录文件inode地址 ,要创建的目录名
{
	if(strlen(name)>=MAX_NAME_SIZE){//如果目录名长度超过最大长度则返回
		printf("超过最大目录名长度\n");
		return false;
	}

	DirItem dirlist[16];	//临时目录清单

	//从这个地址取出inode
	Inode cur;
	fseek(fr,parinoAddr,SEEK_SET);	//将文件指针移动到inode的起始地址
	fread(&cur,sizeof(Inode),1,fr);//将inode内容读出
	
	int i = 0;
	int cnt = cur.i_cnt+1;	//目录项数
	int posi = -1,posj = -1;
	while(i<160){
		//160个目录项之内，可以直接在直接块里找
		int dno = i/16;	//在第几个直接块里

		if(cur.i_dirBlock[dno]==-1){
			i+=16;
			continue;
		}
		//取出这个直接块，要加入的目录条目的位置
		fseek(fr,cur.i_dirBlock[dno],SEEK_SET);	//将文件指针移动到直接块的起始地址
		fread(dirlist,sizeof(dirlist),1,fr);//将直接块内容读出
		fflush(fr);

		//输出该磁盘块中的所有目录项
		int j;
		for(j=0;j<16;j++){

			if( strcmp(dirlist[j].itemName,name)==0 ){
				Inode tmp;
				fseek(fr,dirlist[j].inodeAddr,SEEK_SET);	//将文件指针移动到inode的起始地址
				fread(&tmp,sizeof(Inode),1,fr);//将inode内容读出
				if( ((tmp.i_mode>>9)&1)==1 ){	//不是目录！>>9不知道什么意思
					printf("目录已存在\n");
					return false;
				}
			}
			else if( strcmp(dirlist[j].itemName,"")==0 ){//空目录项
				//找到一个空闲记录，将新目录创建到这个位置 
				//记录这个位置
				if(posi==-1){
					posi = dno;//直接块号
					posj = j;//目录项号
				}

			}
			i++;
		}

	}
	/*  未写完 */

	if(posi!=-1){	//找到这个空闲位置

		//取出这个直接块，要加入的目录条目的位置
		fseek(fr,cur.i_dirBlock[posi],SEEK_SET);	//将文件指针移动到直接块的起始地址
		fread(dirlist,sizeof(dirlist),1,fr);//将直接块内容读出
		fflush(fr);//将缓冲区内容写入文件

		//创建这个目录项
		strcpy(dirlist[posj].itemName,name);	//目录名
		//写入两条记录 "." ".."，分别指向当前inode节点地址，和父inode节点
		int chiinoAddr = ialloc();	//分配当前节点地址 
		if(chiinoAddr==-1){
			printf("inode分配失败\n");
			return false;
		}
		dirlist[posj].inodeAddr = chiinoAddr; //给这个新的目录分配的inode地址

			//设置新条目的inode
			Inode p;
			p.i_ino = (chiinoAddr-Inode_StartAddr)/superblock->s_INODE_SIZE;
			p.i_atime = time(NULL);//最后访问时间
			p.i_ctime = time(NULL);//创建时间
			p.i_mtime = time(NULL);//最后修改时间
			strcpy(p.i_uname,Cur_User_Name);
			strcpy(p.i_gname,Cur_Group_Name);
			p.i_cnt = 2;	//两个项，当前目录,"."和".."

				//分配这个inode的磁盘块，在磁盘号中写入两条记录 . 和 ..
				int curblockAddr = balloc();//分配磁盘块
				if(curblockAddr==-1){
					printf("block分配失败\n");
					return false;
				}
				DirItem dirlist2[16] = {0};	//临时目录项列表 - 2
				strcpy(dirlist2[0].itemName,".");
				strcpy(dirlist2[1].itemName,"..");
				dirlist2[0].inodeAddr = chiinoAddr;	//当前目录inode地址
				dirlist2[1].inodeAddr = parinoAddr;	//父目录inode地址

				//写入到当前目录的磁盘块
				fseek(fw,curblockAddr,SEEK_SET);	//	将文件指针移动到直接块的起始地址
				fwrite(dirlist2,sizeof(dirlist2),1,fw);//将直接块内容写入文件

			p.i_dirBlock[0] = curblockAddr;
			int k;
			for(k=1;k<10;k++){
				p.i_dirBlock[k] = -1;//其他直接块清0
			}
			p.i_size = superblock->s_BLOCK_SIZE;//文件大小
			p.i_indirBlock_1 = -1;	//没使用一级间接块
			p.i_mode = MODE_DIR | DIR_DEF_PERMISSION;

			//将inode写入到申请的inode地址
			fseek(fw,chiinoAddr,SEEK_SET);	
			fwrite(&p,sizeof(Inode),1,fw);

		//将当前目录的磁盘块写回
		fseek(fw,cur.i_dirBlock[posi],SEEK_SET);//将文件指针移动到直接块的起始地址	
		fwrite(dirlist,sizeof(dirlist),1,fw);//将直接块内容写入文件

		//写回inode
		cur.i_cnt++;
		fseek(fw,parinoAddr,SEEK_SET);	//	将文件指针移动到直接块的起始地址
		fwrite(&cur,sizeof(Inode),1,fw);//将直接块内容写入文件
		fflush(fw);
		
		return true;
	}
	else{
		printf("没找到空闲目录项,目录创建失败");
		return false;
	}
}

void rmall(int parinoAddr)	//删除该节点下所有文件或目录
{
	//从这个地址取出inode
	Inode cur;
	fseek(fr,parinoAddr,SEEK_SET);//将文件指针移动到直接块的起始地址
	fread(&cur,sizeof(Inode),1,fr);//将直接块内容写入文件

	//取出目录项数
	int cnt = cur.i_cnt;
	if(cnt<=2){
		bfree(cur.i_dirBlock[0]);//	释放直接块
		ifree(parinoAddr);//释放inode
		return ;
	}

	//依次取出磁盘块
	int i = 0;
	while(i<160){	//小于160
		DirItem dirlist[16] = {0};

		if(cur.i_dirBlock[i/16]==-1){//如果该直接块为空，则跳过
			i+=16;
			continue;
		}
		//取出磁盘块
		int parblockAddr = cur.i_dirBlock[i/16];
		fseek(fr,parblockAddr,SEEK_SET);	//	将文件指针移动到直接块的起始地址
		fread(&dirlist,sizeof(dirlist),1,fr);//将直接块内容写入文件

		//从磁盘块中依次取出目录项，递归删除
		int j;
		bool f = false;
		for(j=0;j<16;j++){
			//Inode tmp;

			if( ! (strcmp(dirlist[j].itemName,".")==0 || 
						strcmp(dirlist[j].itemName,"..")==0 || 
						strcmp(dirlist[j].itemName,"")==0 ) ){//如果不是空目录项
				f = true;
				rmall(dirlist[j].inodeAddr);	//递归删除//通过递归的方式将节点进行删除
			}

			cnt = cur.i_cnt;
			i++;
		}

		//该磁盘块已空，回收
		if(f)
			bfree(parblockAddr);//空了之后将磁盘块 进行回收

	}
	//该inode已空，回收
	ifree(parinoAddr);//空了之后将inode 进行回收
	return ;

}

bool rmdir(int parinoAddr,char name[])	//目录删除函数
{
	if(strlen(name)>=MAX_NAME_SIZE){
		printf("超过最大目录名长度\n");
		return false;
	}

	if(strcmp(name,".")==0 || strcmp(name,"..")==0){
		printf("错误操作\n");
		return 0;
	}

	//从这个地址取出inode
	Inode cur;
	fseek(fr,parinoAddr,SEEK_SET);	
	fread(&cur,sizeof(Inode),1,fr);

	//取出目录项数
	int cnt = cur.i_cnt;

	//判断文件模式。6为owner，3为group，0为other//要先判断权限是否足够之后再对对应的目录进行删除
	int filemode;
	if(strcmp(Cur_User_Name,cur.i_uname)==0 ) 
		filemode = 6;
	else if(strcmp(Cur_User_Name,cur.i_gname)==0)
		filemode = 3;
	else 
		filemode = 0;

	if( (((cur.i_mode>>filemode>>1)&1)==0) && (strcmp(Cur_User_Name,"root")!=0) ){
		//没有写入权限
		printf("权限不足：无写入权限\n");
		return false;
	}


	//依次取出磁盘块
	int i = 0;
	while(i<160){	//小于160
		DirItem dirlist[16] = {0};

		if(cur.i_dirBlock[i/16]==-1){//磁盘块为空，跳过
			i+=16;
			continue;
		}
		//取出磁盘块
		int parblockAddr = cur.i_dirBlock[i/16];
		fseek(fr,parblockAddr,SEEK_SET);	//	将文件指针移动到直接块的起始地址
		fread(&dirlist,sizeof(dirlist),1,fr);//将直接块内容写入文件

		//找到要删除的目录
		int j;
		for(j=0;j<16;j++){
			Inode tmp;
			//取出该目录项的inode，判断该目录项是目录还是文件
			fseek(fr,dirlist[j].inodeAddr,SEEK_SET);	
			fread(&tmp,sizeof(Inode),1,fr);

			if( strcmp(dirlist[j].itemName,name)==0){
				if( ( (tmp.i_mode>>9) & 1 ) == 1 ){	//找到目录
					//是目录

					rmall(dirlist[j].inodeAddr);//目录删除函数

					//删除该目录条目，写回磁盘
					strcpy(dirlist[j].itemName,"");//将该目录条目的名字清空
					dirlist[j].inodeAddr = -1;
					fseek(fw,parblockAddr,SEEK_SET);//将文件指针移动到直接块的起始地址
					fwrite(&dirlist,sizeof(dirlist),1,fw);//将直接块内容写入文件
					cur.i_cnt--;//目录项数减一
					fseek(fw,parinoAddr,SEEK_SET);	
					fwrite(&cur,sizeof(Inode),1,fw);

					fflush(fw);
					return true;
				}
				else{
					//不是目录，不管
				}
			}
			i++;
		}

	}
	
	printf("没有找到该目录\n");
	return false;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool create(int parinoAddr,char name[],char buf[])	//创建文件函数，在该目录下创建文件，文件内容存在buf
{
	if(strlen(name)>=MAX_NAME_SIZE){
		printf("超过最大文件名长度\n");
		return false;
	}

	DirItem dirlist[16];	//临时目录清单

	//从这个地址取出inode
	Inode cur;
	fseek(fr,parinoAddr,SEEK_SET);	
	fread(&cur,sizeof(Inode),1,fr);
	
	int i = 0;
	int posi = -1,posj = -1;	//找到的目录位置
	int dno;
	int cnt = cur.i_cnt+1;	//目录项数
	while(i<160){
		//160个目录项之内，可以直接在直接块里找
		dno = i/16;	//在第几个直接块里

		if(cur.i_dirBlock[dno]==-1){//磁盘块为空，跳过
			i+=16;
			continue;
		}
		fseek(fr,cur.i_dirBlock[dno],SEEK_SET);	
		fread(dirlist,sizeof(dirlist),1,fr);
		fflush(fr);

		//输出该磁盘块中的所有目录项
		int j;
		for(j=0;j<16;j++){

			if( posi==-1 && strcmp(dirlist[j].itemName,"")==0 ){//找到空位置
				//找到一个空闲记录，将新文件创建到这个位置 
				posi = dno;//直接块号
				posj = j;//目录项号
			}
			else if(strcmp(dirlist[j].itemName,name)==0 ){//找到同名文件
				//重名，取出inode，判断是否是文件
				Inode cur2;
				fseek(fr,dirlist[j].inodeAddr,SEEK_SET);	
				fread(&cur2,sizeof(Inode),1,fr);
				if( ((cur2.i_mode>>9)&1)==0 ){	//是文件且重名，不能创建文件
					printf("文件已存在\n");
					buf[0] = '\0';
					return false;
				}
			}
			i++;
		}

	}
	if(posi!=-1){	//之前找到一个目录项了
		//取出之前那个空闲目录项对应的磁盘块
		fseek(fr,cur.i_dirBlock[posi],SEEK_SET);//将文件指针移动到直接块的起始地址	
		fread(dirlist,sizeof(dirlist),1,fr);//将直接块内容写入文件
		fflush(fr);

		//创建这个目录项
		strcpy(dirlist[posj].itemName,name);	//文件名
		int chiinoAddr = ialloc();	//分配当前节点地址 
		if(chiinoAddr==-1){
			printf("inode分配失败\n");
			return false;
		}
		dirlist[posj].inodeAddr = chiinoAddr; //给这个新的目录分配的inode地址

			//设置新条目的inode
			Inode p;
			p.i_ino = (chiinoAddr-Inode_StartAddr)/superblock->s_INODE_SIZE;//inode号
			p.i_atime = time(NULL);//最后访问时间
			p.i_ctime = time(NULL);//创建时间
			p.i_mtime = time(NULL);//最后修改时间
			strcpy(p.i_uname,Cur_User_Name);
			strcpy(p.i_gname,Cur_Group_Name);
			p.i_cnt = 1;	//只有一个文件指向


				//将buf内容存到磁盘块 
				int k;
				int len = strlen(buf);	//文件长度，单位为字节
				for(k=0;k<len;k+=superblock->s_BLOCK_SIZE){	//最多10次，10个磁盘快，即最多5K//限定创建的文件的大小
					//分配这个inode的磁盘块，从控制台读取内容
					int curblockAddr = balloc();//分配一个磁盘块
					if(curblockAddr==-1){
						printf("block分配失败\n");
						return false;
					}
					p.i_dirBlock[k/superblock->s_BLOCK_SIZE] = curblockAddr;
					//写入到当前目录的磁盘块
					fseek(fw,curblockAddr,SEEK_SET);	
					fwrite(buf+k,superblock->s_BLOCK_SIZE,1,fw);
				}
				

			for(k=len/superblock->s_BLOCK_SIZE+1;k<10;k++){
				p.i_dirBlock[k] = -1;
			}
			if(len==0){	//长度为0的话也分给它一个block
				int curblockAddr = balloc();
				if(curblockAddr==-1){
					printf("block分配失败\n");
					return false;
				}
				p.i_dirBlock[k/superblock->s_BLOCK_SIZE] = curblockAddr;
				//写入到当前目录的磁盘块
				fseek(fw,curblockAddr,SEEK_SET);	
				fwrite(buf,superblock->s_BLOCK_SIZE,1,fw);

			}
			p.i_size = len;//文件长度
			p.i_indirBlock_1 = -1;	//没使用一级间接块
			p.i_mode = 0;
			p.i_mode = MODE_FILE | FILE_DEF_PERMISSION;//文件权限

			//将inode写入到申请的inode地址
			fseek(fw,chiinoAddr,SEEK_SET);	
			fwrite(&p,sizeof(Inode),1,fw);

		//将当前目录的磁盘块写回
		fseek(fw,cur.i_dirBlock[posi],SEEK_SET);	
		fwrite(dirlist,sizeof(dirlist),1,fw);

		//写回inode
		cur.i_cnt++;
		fseek(fw,parinoAddr,SEEK_SET);	
		fwrite(&cur,sizeof(Inode),1,fw);
		fflush(fw);

		return true;
	}
	else
		return false;
}
//该函数在找到对应的文件之后只负责去删除对应的函数 如果传入的目录的话不会进行操作
bool del(int parinoAddr,char name[])		//删除文件函数。在当前目录下删除文件
{
	
	if(strlen(name)>=MAX_NAME_SIZE){
		printf("超过最大目录名长度\n");
		return false;
	}

	//从这个地址取出inode
	Inode cur;
	fseek(fr,parinoAddr,SEEK_SET);	
	fread(&cur,sizeof(Inode),1,fr);

	//取出目录项数
	int cnt = cur.i_cnt;

	//判断文件模式。6为owner，3为group，0为other//判断文件模式并且判断用户是否具有权限
	int filemode;
	if(strcmp(Cur_User_Name,cur.i_uname)==0 ) 
		filemode = 6;
	else if(strcmp(Cur_User_Name,cur.i_gname)==0)
		filemode = 3;
	else 
		filemode = 0;

	if( ((cur.i_mode>>filemode>>1)&1)==0 ){
		//没有写入权限
		printf("权限不足：无写入权限\n");
		return false;
	}

	//依次取出磁盘块
	int i = 0;
	while(i<160){	//小于160
		DirItem dirlist[16] = {0};

		if(cur.i_dirBlock[i/16]==-1){
			i+=16;
			continue;
		}
		//取出磁盘块
		int parblockAddr = cur.i_dirBlock[i/16];
		fseek(fr,parblockAddr,SEEK_SET);	
		fread(&dirlist,sizeof(dirlist),1,fr);

		//找到要删除的目录
		int pos;
		for(pos=0;pos<16;pos++){
			Inode tmp;
			//取出该目录项的inode，判断该目录项是目录还是文件
			fseek(fr,dirlist[pos].inodeAddr,SEEK_SET);	
			fread(&tmp,sizeof(Inode),1,fr);

			if( strcmp(dirlist[pos].itemName,name)==0){
				if( ( (tmp.i_mode>>9) & 1 ) == 1 ){	//找到目录
					//是目录，不管
				}
				else{
					//是文件

					//释放block
					int k;
					for(k=0;k<10;k++)
						if(tmp.i_dirBlock[k]!=-1)
							bfree(tmp.i_dirBlock[k]);

					//释放inode
					ifree(dirlist[pos].inodeAddr);

					//删除该目录条目，写回磁盘
					strcpy(dirlist[pos].itemName,"");
					dirlist[pos].inodeAddr = -1;
					fseek(fw,parblockAddr,SEEK_SET);	
					fwrite(&dirlist,sizeof(dirlist),1,fw);
					cur.i_cnt--;
					fseek(fw,parinoAddr,SEEK_SET);	
					fwrite(&cur,sizeof(Inode),1,fw);

					fflush(fw);
					return true;
				}
			}
			i++;
		}

	}
	
	printf("没有找到该文件!\n");
	return false;
}


void ls(int parinoAddr)		//显示当前目录下的所有文件和文件夹。参数：当前目录的inode节点地址 
{
	Inode cur;
	//取出这个inode
	fseek(fr,parinoAddr,SEEK_SET);	
	fread(&cur,sizeof(Inode),1,fr);
	fflush(fr);

	//取出目录项数
	int cnt = cur.i_cnt;
	//查看权限以及取出对应的磁盘块
	//判断文件模式。6为owner，3为group，0为other
	int filemode;
	if(strcmp(Cur_User_Name,cur.i_uname)==0 ) 
		filemode = 6;
	else if(strcmp(Cur_User_Name,cur.i_gname)==0)
		filemode = 3;
	else 
		filemode = 0;

	if( ((cur.i_mode>>filemode>>2)&1)==0 ){
		//没有读取权限
		printf("权限不足：无读取权限\n");
		return ;
	}

	//依次取出磁盘块
	int i = 0;
	while(i<cnt && i<160){
		DirItem dirlist[16] = {0};
		if(cur.i_dirBlock[i/16]==-1){
			i+=16;
			continue;
		}
		//取出磁盘块
		int parblockAddr = cur.i_dirBlock[i/16];
		fseek(fr,parblockAddr,SEEK_SET);	
		fread(&dirlist,sizeof(dirlist),1,fr);
		fflush(fr);

		//输出该磁盘块中的所有目录项
		int j;
		for(j=0;j<16 && i<cnt;j++){
			Inode tmp;
			//取出该目录项的inode，判断该目录项是目录还是文件
			fseek(fr,dirlist[j].inodeAddr,SEEK_SET);	
			fread(&tmp,sizeof(Inode),1,fr);
			fflush(fr);

			if( strcmp(dirlist[j].itemName,"")==0 ){
				continue;
			}

			//输出信息
			if( ( (tmp.i_mode>>9) & 1 ) == 1 ){//是目录
				printf("d");
			}
			else{
				printf("-");//是文件
			}

			tm *ptr;	//存储时间
			ptr=gmtime(&tmp.i_mtime);

			//输出权限信息
			int t = 8;
			while(t>=0){
				if( ((tmp.i_mode>>t)&1)==1){
					if(t%3==2)	printf("r");//读
					if(t%3==1)	printf("w");//写
					if(t%3==0)	printf("x");//执行
				}
				else{
					printf("-");
				}
				t--;
			}
			printf("\t");

			//其它
			printf("%d\t",tmp.i_cnt);	//链接
			printf("%s\t",tmp.i_uname);	//文件所属用户名
			printf("%s\t",tmp.i_gname);	//文件所属用户名
			printf("%d B\t",tmp.i_size);	//文件大小
			printf("%d.%d.%d %02d:%02d:%02d  ",1900+ptr->tm_year,ptr->tm_mon+1,ptr->tm_mday,(8+ptr->tm_hour)%24,ptr->tm_min,ptr->tm_sec);	//上一次修改的时间
			printf("%s",dirlist[j].itemName);	//文件名
			printf("\n");
			i++;
		}

	}
	/*  未写完 */

}

void cd(int parinoAddr,char name[])	//进入当前目录下的name目录
{
	//取出当前目录的inode
	Inode cur;
	fseek(fr,parinoAddr,SEEK_SET);	
	fread(&cur,sizeof(Inode),1,fr);

	//依次取出inode对应的磁盘块，查找有没有名字为name的目录项
	int i = 0;

	//取出目录项数
	int cnt = cur.i_cnt;
	//查看权限以及取出对应的磁盘块
	//判断文件模式。6为owner，3为group，0为other
	int filemode;
	if(strcmp(Cur_User_Name,cur.i_uname)==0 ) 
		filemode = 6;
	else if(strcmp(Cur_User_Name,cur.i_gname)==0)
		filemode = 3;
	else 
		filemode = 0;

	while(i<160){
		DirItem dirlist[16] = {0};
		if(cur.i_dirBlock[i/16]==-1){
			i+=16;
			continue;
		}
		//取出磁盘块
		int parblockAddr = cur.i_dirBlock[i/16];
		fseek(fr,parblockAddr,SEEK_SET);	
		fread(&dirlist,sizeof(dirlist),1,fr);

		//输出该磁盘块中的所有目录项
		int j;
		for(j=0;j<16;j++){
			if(strcmp(dirlist[j].itemName,name)==0){
				Inode tmp;
				//取出该目录项的inode，判断该目录项是目录还是文件
				fseek(fr,dirlist[j].inodeAddr,SEEK_SET);	
				fread(&tmp,sizeof(Inode),1,fr);

				if( ( (tmp.i_mode>>9) & 1 ) == 1 ){
					//找到该目录，判断是否具有进入权限
					if( ((tmp.i_mode>>filemode>>0)&1)==0 && strcmp(Cur_User_Name,"root")!=0 ){	//root用户所有目录都可以查看 
						//没有执行权限
						printf("权限不足：无执行权限\n");
						return ;
					}

					//找到该目录项，如果是目录，更换当前目录

					Cur_Dir_Addr = dirlist[j].inodeAddr;
					if( strcmp(dirlist[j].itemName,".")==0){//当前目录
						//本目录，不动
					}
					else if(strcmp(dirlist[j].itemName,"..")==0){//上一级目录
						//上一次目录
						int k;
						for(k=strlen(Cur_Dir_Name);k>=0;k--)
							if(Cur_Dir_Name[k]=='/')//找到上一级目录
								break;
						Cur_Dir_Name[k]='\0';//截断的文件结构能够知道前面的是什么
						if(strlen(Cur_Dir_Name)==0)//当前目录为根目录
							Cur_Dir_Name[0]='/',Cur_Dir_Name[1]='\0';//根目录
					}
					else{
						if(Cur_Dir_Name[strlen(Cur_Dir_Name)-1]!='/')//当前目录不是根目录
							strcat(Cur_Dir_Name,"/");
						strcat(Cur_Dir_Name,dirlist[j].itemName);//更换当前目录
					}

					return ;
				}
				else{
					//找到该目录项，如果不是目录，继续找
				}
				
			}

			i++;
		}

	}
	
	//没找到
	printf("没有该目录\n");
	return ;

}

void gotoxy(HANDLE hOut, int x, int y)	//移动光标到指定位置
{
      COORD pos;
      pos.X = x;             //横坐标
      pos.Y = y;            //纵坐标
      SetConsoleCursorPosition(hOut, pos);
}

void vi(int parinoAddr,char name[],char buf[])	//模拟一个简单vi，输入文本，name为文件名
{
	//先判断文件是否已存在。如果存在，打开这个文件并编辑
	if(strlen(name)>=MAX_NAME_SIZE){
		printf("超过最大文件名长度\n");
		return ;
	}

	//清空缓冲区
	memset(buf,0,sizeof(buf));
	int maxlen = 0;	//到达过的最大长度

	//查找有无同名文件，有的话进入编辑模式，没有进入创建文件模式
	DirItem dirlist[16];	//临时目录清单

	//从这个地址取出inode
	Inode cur,fileInode;
	fseek(fr,parinoAddr,SEEK_SET);	
	fread(&cur,sizeof(Inode),1,fr);

	//判断文件模式。6为owner，3为group，0为other
	int filemode;
	if(strcmp(Cur_User_Name,cur.i_uname)==0 ) 
		filemode = 6;
	else if(strcmp(Cur_User_Name,cur.i_gname)==0)
		filemode = 3;
	else 
		filemode = 0;
	
	int i = 0,j;
	int dno;
	int fileInodeAddr = -1;	//文件的inode地址
	bool isExist = false;	//文件是否已存在
	while(i<160){
		//160个目录项之内，可以直接在直接块里找
		dno = i/16;	//在第几个直接块里

		if(cur.i_dirBlock[dno]==-1){
			i+=16;
			continue;
		}
		fseek(fr,cur.i_dirBlock[dno],SEEK_SET);	
		fread(dirlist,sizeof(dirlist),1,fr);
		fflush(fr);

		//输出该磁盘块中的所有目录项
		for(j=0;j<16;j++){
			if(strcmp(dirlist[j].itemName,name)==0 ){
				//重名，取出inode，判断是否是文件
				fseek(fr,dirlist[j].inodeAddr,SEEK_SET);	
				fread(&fileInode,sizeof(Inode),1,fr);
				if( ((fileInode.i_mode>>9)&1)==0 ){	//是文件且重名，打开这个文件，并编辑	
					fileInodeAddr = dirlist[j].inodeAddr;
					isExist = true;
					goto label;
				}
			}
			i++;
		}
	}
label:

	//初始化vi
	int cnt = 0;
	system("cls");	//清屏

	int winx,winy,curx,cury;

	HANDLE handle_out;                              //定义一个句柄  
	CONSOLE_SCREEN_BUFFER_INFO screen_info;         //定义窗口缓冲区信息结构体  
	COORD pos = {0, 0};                             //定义一个坐标结构体

	if(isExist){	//文件已存在，进入编辑模式，先输出之前的文件内容

		//权限判断。判断文件是否可读
		if( ((fileInode.i_mode>>filemode>>2)&1)==0){
			//不可读
			printf("权限不足：没有读权限\n");
			return ;
		}

		//将文件内容读取出来，显示在，窗口上
		i = 0;
		int sumlen = fileInode.i_size;	//文件长度
		int getlen = 0;	//取出来的长度
		for(i=0;i<10;i++){
			char fileContent[1000] = {0};
			if(fileInode.i_dirBlock[i]==-1){
				continue;
			}
			//依次取出磁盘块的内容
			fseek(fr,fileInode.i_dirBlock[i],SEEK_SET);	
			fread(fileContent,superblock->s_BLOCK_SIZE,1,fr);	//读取出一个磁盘块大小的内容
			fflush(fr);
			//输出字符串
			int curlen = 0;	//当前指针
			while(curlen<superblock->s_BLOCK_SIZE){
				if(getlen>=sumlen)	//全部输出完毕
					break;
				printf("%c",fileContent[curlen]);	//输出到屏幕 
				buf[cnt++] = fileContent[curlen];	//输出到buf
				curlen++;
				getlen++;
			}
			if(getlen>=sumlen)
				break;
		}
		maxlen = sumlen;
	}  

	//获得输出之后的光标位置
	handle_out = GetStdHandle(STD_OUTPUT_HANDLE);   //获得标准输出设备句柄  
	GetConsoleScreenBufferInfo(handle_out, &screen_info);   //获取窗口信息  
	winx = screen_info.srWindow.Right - screen_info.srWindow.Left + 1;
	winy = screen_info.srWindow.Bottom - screen_info.srWindow.Top + 1;
	curx = screen_info.dwCursorPosition.X;
	cury = screen_info.dwCursorPosition.Y;


	//进入vi
	//先用vi读取文件内容

	int mode = 0;	//vi模式，一开始是命令模式
	unsigned char c;
	while(1){
		if(mode==0){	//命令行模式
			c=getch();
			
			if(c=='i' || c=='a'){	//插入模式
				if(c=='a'){
					curx++;
					if(curx==winx){
						curx = 0;
						cury++;
					
						/*
						if(cury>winy-2 || cury%(winy-1)==winy-2){
							//超过这一屏，向下翻页
							if(cury%(winy-1)==winy-2)
								printf("\n");
							SetConsoleTextAttribute(handle_out, screen_info.wAttributes); // 恢复原来的属性
							int i;
							for(i=0;i<winx-1;i++)
								printf(" ");
							gotoxy(handle_out,0,cury+1);
							printf(" - 插入模式 - ");
							gotoxy(handle_out,0,cury);
						}
						*/
					}
				}
				
				if(cury>winy-2 || cury%(winy-1)==winy-2){
					//超过这一屏，向下翻页
					if(cury%(winy-1)==winy-2)
						printf("\n");
					SetConsoleTextAttribute(handle_out, screen_info.wAttributes); // 恢复原来的属性
					int i;
					for(i=0;i<winx-1;i++)
						printf(" ");
					gotoxy(handle_out,0,cury+1);
					printf(" - 插入模式 - ");
					gotoxy(handle_out,0,cury);
				}	
				else{
					//显示 "插入模式"
					gotoxy(handle_out,0,winy-1);
					SetConsoleTextAttribute(handle_out, screen_info.wAttributes); // 恢复原来的属性
					int i;
					for(i=0;i<winx-1;i++)
						printf(" ");
					gotoxy(handle_out,0,winy-1);
					printf(" - 插入模式 - ");
					gotoxy(handle_out,curx,cury);
				}

				gotoxy(handle_out,curx,cury);
				mode = 1;
			

			}
			else if(c==':'){
				//system("color 09");//设置文本为蓝色
				if(cury-winy+2>0)
					gotoxy(handle_out,0,cury+1);
				else
					gotoxy(handle_out,0,winy-1);
				_COORD pos;
				if(cury-winy+2>0)
					pos.X = 0,pos.Y = cury+1;
				else
					pos.X = 0,pos.Y = winy-1;
				SetConsoleTextAttribute(handle_out, screen_info.wAttributes); // 恢复原来的属性
				int i;
				for(i=0;i<winx-1;i++)
					printf(" ");

				if(cury-winy+2>0)
					gotoxy(handle_out,0,cury+1);
				else
				gotoxy(handle_out,0,winy-1);

				WORD att = BACKGROUND_RED | BACKGROUND_BLUE | FOREGROUND_INTENSITY; // 文本属性
				FillConsoleOutputAttribute(handle_out, att, winx, pos, NULL);	//控制台部分着色 
				SetConsoleTextAttribute(handle_out, FOREGROUND_INTENSITY | BACKGROUND_RED | BACKGROUND_BLUE | FOREGROUND_GREEN  );	//设置文本颜色
				printf(":");
				
				char pc;
				int tcnt = 1;	//命令行模式输入的字符计数
				while( c = getch() ){
					if(c=='\r'){	//回车
						break;
					}
					else if(c=='\b'){	//退格，从命令条删除一个字符 
						//SetConsoleTextAttribute(handle_out, screen_info.wAttributes); // 恢复原来的属性
						tcnt--;
						if(tcnt==0)	
							break;
						printf("\b");
						printf(" ");
						printf("\b");
						continue;
					}
					pc = c;
					printf("%c",pc);
					tcnt++;
				}
				if(pc=='q'){
					buf[cnt] = '\0'; 
					//buf[maxlen] = '\0'; 
					SetConsoleTextAttribute(handle_out, screen_info.wAttributes); // 恢复原来的属性
					system("cls");
					break;	//vi >>>>>>>>>>>>>> 退出出口
				}
				else{
					if(cury-winy+2>0)
						gotoxy(handle_out,0,cury+1);
					else
						gotoxy(handle_out,0,winy-1);
					SetConsoleTextAttribute(handle_out, screen_info.wAttributes); // 恢复原来的属性
					int i;
					for(i=0;i<winx-1;i++)
						printf(" ");

					if(cury-winy+2>0)
						gotoxy(handle_out,0,cury+1);
					else
						gotoxy(handle_out,0,winy-1);
					SetConsoleTextAttribute(handle_out, FOREGROUND_INTENSITY | BACKGROUND_RED | BACKGROUND_BLUE | FOREGROUND_GREEN  );	//设置文本颜色
					FillConsoleOutputAttribute(handle_out, att, winx, pos, NULL);	//控制台部分着色
					printf(" 错误命令");
					//getch();
					SetConsoleTextAttribute(handle_out, screen_info.wAttributes); // 恢复原来的属性
					gotoxy(handle_out,curx,cury);
				}
			}
			else if(c==27){	//ESC，命令行模式，清状态条
				gotoxy(handle_out,0,winy-1);
				SetConsoleTextAttribute(handle_out, screen_info.wAttributes); // 恢复原来的属性
				int i;
				for(i=0;i<winx-1;i++)
					printf(" ");
				gotoxy(handle_out,curx,cury);

			}
		
		}
		else if(mode==1){	//插入模式
		
			gotoxy(handle_out,winx/4*3,winy-1);
			int i = winx/4*3;
			while(i<winx-1){
				printf(" ");
				i++;
			}
			if(cury>winy-2)
				gotoxy(handle_out,winx/4*3,cury+1);
			else
				gotoxy(handle_out,winx/4*3,winy-1);
			printf("[行:%d,列:%d]",curx==-1?0:curx,cury);
			gotoxy(handle_out,curx,cury);

			c = getch();
			if(c==27){	// ESC，进入命令模式
				mode = 0;
				//清状态条
				gotoxy(handle_out,0,winy-1);
				SetConsoleTextAttribute(handle_out, screen_info.wAttributes); // 恢复原来的属性
				int i;
				for(i=0;i<winx-1;i++)
					printf(" ");
				continue;
			}
			else if(c=='\b'){	//退格，删除一个字符
				if(cnt==0)	//已经退到最开始
					continue;
				printf("\b");
				printf(" ");
				printf("\b");
				curx--;
				cnt--;	//删除字符
				if(buf[cnt]=='\n'){
					//要删除的这个字符是回车，光标回到上一行
					if(cury!=0)
						cury--;
					int k;
					curx = 0;
					for(k = cnt-1;buf[k]!='\n' && k>=0;k--)
						curx++;
					gotoxy(handle_out,curx,cury);
					printf(" ");
					gotoxy(handle_out,curx,cury);
					if(cury-winy+2>=0){	//翻页时
						gotoxy(handle_out,curx,0);
						gotoxy(handle_out,curx,cury+1);
						SetConsoleTextAttribute(handle_out, screen_info.wAttributes); // 恢复原来的属性
						int i;
						for(i=0;i<winx-1;i++)
							printf(" ");
						gotoxy(handle_out,0,cury+1);
						printf(" - 插入模式 - ");

					}
					gotoxy(handle_out,curx,cury);

				}
				else
					buf[cnt] = ' ';
				continue;
			}
			else if(c==224){	//判断是否是箭头
				c = getch();
				if(c==75){	//左箭头
					if(cnt!=0){
						cnt--;
						curx--;
						if(buf[cnt]=='\n'){
							//上一个字符是回车
							if(cury!=0)
								cury--;
							int k;
							curx = 0;
							for(k = cnt-1;buf[k]!='\n' && k>=0;k--)
								curx++;
						}
						gotoxy(handle_out,curx,cury);
					}
				}
				else if(c==77){	//右箭头
					cnt++;
					if(cnt>maxlen)
						maxlen = cnt;
					curx++;
					if(curx==winx){
						curx = 0;
						cury++;

						if(cury>winy-2 || cury%(winy-1)==winy-2){
							//超过这一屏，向下翻页
							if(cury%(winy-1)==winy-2)
								printf("\n");
							SetConsoleTextAttribute(handle_out, screen_info.wAttributes); // 恢复原来的属性
							int i;
							for(i=0;i<winx-1;i++)
								printf(" ");
							gotoxy(handle_out,0,cury+1);
							printf(" - 插入模式 - ");
							gotoxy(handle_out,0,cury);
						}

					}
					gotoxy(handle_out,curx,cury);
				}
				continue;
			}
			if(c=='\r'){	//遇到回车
				printf("\n");
				curx = 0;
				cury++;
		
				if(cury>winy-2 || cury%(winy-1)==winy-2){
					//超过这一屏，向下翻页
					if(cury%(winy-1)==winy-2)
						printf("\n");
					SetConsoleTextAttribute(handle_out, screen_info.wAttributes); // 恢复原来的属性
					int i;
					for(i=0;i<winx-1;i++)
						printf(" ");
					gotoxy(handle_out,0,cury+1);
					printf(" - 插入模式 - ");
					gotoxy(handle_out,0,cury);
				}

				buf[cnt++] = '\n';
				if(cnt>maxlen)
					maxlen = cnt;
				continue;
			}
			else{
				printf("%c",c);
			}
			//移动光标
			curx++;
			if(curx==winx){
				curx = 0;
				cury++;
	
				if(cury>winy-2 || cury%(winy-1)==winy-2){
					//超过这一屏，向下翻页
					if(cury%(winy-1)==winy-2)
						printf("\n");
					SetConsoleTextAttribute(handle_out, screen_info.wAttributes); // 恢复原来的属性
					int i;
					for(i=0;i<winx-1;i++)
						printf(" ");
					gotoxy(handle_out,0,cury+1);
					printf(" - 插入模式 - ");
					gotoxy(handle_out,0,cury);
				}

				buf[cnt++] = '\n';
				if(cnt>maxlen)
					maxlen = cnt;
				if(cury==winy){
					printf("\n");
				}
			}
			//记录字符 
			buf[cnt++] = c;
			if(cnt>maxlen)
				maxlen = cnt;
		}
		else{	//其他模式
		}
	}
	if(isExist){	//如果是编辑模式
		//将buf内容写回文件的磁盘块

		if( ((fileInode.i_mode>>filemode>>1)&1)==1 ){	//可写
			writefile(fileInode,fileInodeAddr,buf);
		}
		else{	//不可写
			printf("权限不足：无写入权限\n");
		}

	}
	else{	//是创建文件模式
		if( ((cur.i_mode>>filemode>>1)&1)==1){
			//可写。可以创建文件
			create(parinoAddr,name,buf);	//创建文件
		}
		else{
			printf("权限不足：无写入权限\n");
			return ;
		}
	}
}

void writefile(Inode fileInode,int fileInodeAddr,char buf[])	//将buf内容写回文件的磁盘块
{
	//将buf内容写回磁盘块 
	int k;
	int len = strlen(buf);	//文件长度，单位为字节
	for(k=0;k<len;k+=superblock->s_BLOCK_SIZE){	//最多10次，10个磁盘快，即最多5K
		//分配这个inode的磁盘块，从控制台读取内容
		int curblockAddr;
		if(fileInode.i_dirBlock[k/superblock->s_BLOCK_SIZE]==-1){
			//缺少磁盘块，申请一个
			curblockAddr = balloc();
			if(curblockAddr==-1){
				printf("block分配失败\n");
				return ;
			}
			fileInode.i_dirBlock[k/superblock->s_BLOCK_SIZE] = curblockAddr;
		}
		else{
			curblockAddr = fileInode.i_dirBlock[k/superblock->s_BLOCK_SIZE];
		}
		//写入到当前目录的磁盘块
		fseek(fw,curblockAddr,SEEK_SET);	
		fwrite(buf+k,superblock->s_BLOCK_SIZE,1,fw);
		fflush(fw);
	}
	//更新该文件大小
	fileInode.i_size = len;
	fileInode.i_mtime = time(NULL);
	fseek(fw,fileInodeAddr,SEEK_SET);	
	fwrite(&fileInode,sizeof(Inode),1,fw);
	fflush(fw);
}

void inUsername(char username[])	//输入用户名
{
	printf("username:");
	scanf("%s",username);	//用户名
}

void inPasswd(char passwd[])	//输入密码
{
	int plen = 0;
	char c;
	fflush(stdin);	//清空缓冲区
	printf("passwd:");
	while(c=getch()){
		if(c=='\r'){	//输入回车，密码确定
			passwd[plen] = '\0';
			fflush(stdin);	//清缓冲区
			printf("\n");
			break;
		}
		else if(c=='\b'){	//退格，删除一个字符
			if(plen!=0){	//没有删到头
				plen--;
			}
		}
		else{	//密码字符
			passwd[plen++] = c;
		}
	}
}

bool login()	//登陆界面
{
	char username[100] = {0};
	char passwd[100] = {0};
	inUsername(username);	//输入用户名//L两个输入的用户名和用户密码
	inPasswd(passwd);		//输入用户密码
	if(check(username,passwd)){	//核对用户名和密码
		isLogin = true;
		return true;
	}
	else{
		isLogin = false;
		return false;
	}
}

bool check(char username[],char passwd[])	//核对用户名，密码L进入配置文件 将信息提取出来与用户输入的用户名和密码进行配对
{
	int passwd_Inode_Addr = -1;	//用户文件inode地址
	int shadow_Inode_Addr = -1;	//用户密码文件inode地址
	Inode passwd_Inode;		//用户文件的inode
	Inode shadow_Inode;		//用户密码文件的inode

	Inode cur_dir_inode;	//当前目录的inode
	int i,j;
	DirItem dirlist[16];	//临时目录

	cd(Cur_Dir_Addr,"etc");	//进入配置文件目录//L打开etc的配置文件

	//找到passwd和shadow文件inode地址，并取出
	//取出当前目录的inode
	fseek(fr,Cur_Dir_Addr,SEEK_SET);	
	fread(&cur_dir_inode,sizeof(Inode),1,fr);
	//依次取出磁盘块，查找passwd文件的inode地址，和shadow文件的inode地址
	for(i=0;i<10;i++){
		if(cur_dir_inode.i_dirBlock[i]==-1){
			continue;
		}
		//依次取出磁盘块
		fseek(fr,cur_dir_inode.i_dirBlock[i],SEEK_SET);	
		fread(&dirlist,sizeof(dirlist),1,fr);

		for(j=0;j<16;j++){	//遍历目录项
			if( strcmp(dirlist[j].itemName,"passwd")==0 ||	//找到passwd或者shadow条目
				strcmp(dirlist[j].itemName,"shadow")==0  ){
				Inode tmp;	//临时inode
				//取出inode，判断是否是文件
				fseek(fr,dirlist[j].inodeAddr,SEEK_SET);	
				fread(&tmp,sizeof(Inode),1,fr);

				if( ((tmp.i_mode>>9)&1)==0 ){	
					//是文件
					//判别是passwd文件还是shadow文件
					if( strcmp(dirlist[j].itemName,"passwd")==0 ){	
						passwd_Inode_Addr = dirlist[j].inodeAddr;
						passwd_Inode = tmp;
					}
					else if(strcmp(dirlist[j].itemName,"shadow")==0 ){
						shadow_Inode_Addr = dirlist[j].inodeAddr;
						shadow_Inode = tmp;
					}
				}
			}
		}
		if(passwd_Inode_Addr!=-1 && shadow_Inode_Addr!=-1)	//都找到了
			break;
	}

	//查找passwd文件，看是否存在用户username
	char buf[1000000];	//最大1M，暂存passwd的文件内容
	char buf2[600];		//暂存磁盘块内容
	j = 0;	//磁盘块指针
	//取出passwd文件内容
	for(i=0;i<passwd_Inode.i_size;i++){
		if(i%superblock->s_BLOCK_SIZE==0){	//超出了
			//换新的磁盘块
			fseek(fr,passwd_Inode.i_dirBlock[i/superblock->s_BLOCK_SIZE],SEEK_SET);	
			fread(&buf2,superblock->s_BLOCK_SIZE,1,fr);
			j = 0;
		}
		buf[i] = buf2[j++];
	}
	buf[i] = '\0';
	if(strstr(buf,username)==NULL){
		//没找到该用户
		printf("用户不存在\n");
		cd(Cur_Dir_Addr,"..");	//回到根目录
		return false;
	}

	//如果存在，查看shadow文件，取出密码，核对passwd是否正确
	//取出shadow文件内容
	j = 0;
	for(i=0;i<shadow_Inode.i_size;i++){
		if(i%superblock->s_BLOCK_SIZE==0){	//超出了这个磁盘块
			//换新的磁盘块
			fseek(fr,shadow_Inode.i_dirBlock[i/superblock->s_BLOCK_SIZE],SEEK_SET);	
			fread(&buf2,superblock->s_BLOCK_SIZE,1,fr);
			j = 0;
		}
		buf[i] = buf2[j++];
	}
	buf[i] = '\0';

	char *p;	//字符指针
	if( (p = strstr(buf,username))==NULL){
		//没找到该用户
		printf("shadow文件中不存在该用户\n");
		cd(Cur_Dir_Addr,"..");	//回到根目录
		return false;
	}
	//找到该用户，取出密码
	while((*p)!=':'){
		p++;
	}
	p++;
	j = 0;
	while((*p)!='\n'){
		buf2[j++] = *p;
		p++;
	}
	buf2[j] = '\0';

	//核对密码
	if(strcmp(buf2,passwd)==0){	//密码正确，登陆
		strcpy(Cur_User_Name,username);
		if(strcmp(username,"root")==0)
			strcpy(Cur_Group_Name,"root");	//当前登陆用户组名
		else
			strcpy(Cur_Group_Name,"user");	//当前登陆用户组名
		cd(Cur_Dir_Addr,"..");
		cd(Cur_Dir_Addr,"home");\
		cd(Cur_Dir_Addr,username);	//进入到用户目录
		strcpy(Cur_User_Dir_Name,Cur_Dir_Name);	//复制当前登陆用户目录名
		return true;
	}
	else{
		printf("密码错误\n");
		cd(Cur_Dir_Addr,"..");	//回到根目录
		return false;
	}
}

void gotoRoot()	//回到根目录
{
	memset(Cur_User_Name,0,sizeof(Cur_User_Name));		//清空当前用户名
	memset(Cur_User_Dir_Name,0,sizeof(Cur_User_Dir_Name));	//清空当前用户目录
	Cur_Dir_Addr = Root_Dir_Addr;	//当前用户目录地址设为根目录地址
	strcpy(Cur_Dir_Name,"/");		//当前目录设为"/"
}

void logout()	//用户注销
{
	//回到根目录
	gotoRoot();

	isLogin = false;
	printf("用户注销\n");
	system("pause");
	system("cls");
}

bool useradd(char username[])	//用户注册
{
	if(strcmp(Cur_User_Name,"root")!=0){
		printf("权限不足\n");
		return false;
	}
	int passwd_Inode_Addr = -1;	//用户文件inode地址
	int shadow_Inode_Addr = -1;	//用户密码文件inode地址
	int group_Inode_Addr = -1;	//用户组文件inode地址
	Inode passwd_Inode;		//用户文件的inode
	Inode shadow_Inode;		//用户密码文件的inode
	Inode group_Inode;		//用户组文件inode
	//原来的目录
	char bak_Cur_User_Name[110];
	char bak_Cur_User_Name_2[110];
	char bak_Cur_User_Dir_Name[310];
	int bak_Cur_Dir_Addr;
	char bak_Cur_Dir_Name[310];
	char bak_Cur_Group_Name[310];

	Inode cur_dir_inode;	//当前目录的inode
	int i,j;
	DirItem dirlist[16];	//临时目录

	//保存现场，回到根目录
	strcpy(bak_Cur_User_Name,Cur_User_Name);
	strcpy(bak_Cur_User_Dir_Name,Cur_User_Dir_Name);
	bak_Cur_Dir_Addr = Cur_Dir_Addr;
	strcpy(bak_Cur_Dir_Name,Cur_Dir_Name);

	//创建用户目录
	gotoRoot();
	cd(Cur_Dir_Addr,"home");
	//保存现场
	strcpy( bak_Cur_User_Name_2 , Cur_User_Name);
	strcpy( bak_Cur_Group_Name , Cur_Group_Name);
	//更改
	strcpy(Cur_User_Name,username);
	strcpy(Cur_Group_Name,"user");
	if(!mkdir(Cur_Dir_Addr,username)){
		strcpy( Cur_User_Name,bak_Cur_User_Name_2);
		strcpy( Cur_Group_Name,bak_Cur_Group_Name);
		//恢复现场，回到原来的目录
		strcpy(Cur_User_Name,bak_Cur_User_Name);
		strcpy(Cur_User_Dir_Name,bak_Cur_User_Dir_Name);
		Cur_Dir_Addr = bak_Cur_Dir_Addr;
		strcpy(Cur_Dir_Name,bak_Cur_Dir_Name);

		printf("用户注册失败!\n");
		return false;
	}
	//恢复现场
	strcpy( Cur_User_Name,bak_Cur_User_Name_2);
	strcpy( Cur_Group_Name,bak_Cur_Group_Name);

	//回到根目录
	gotoRoot();

	//进入用户目录
	cd(Cur_Dir_Addr,"etc");

	//输入用户密码
	char passwd[100] = {0};
	inPasswd(passwd);	//输入密码

	//找到passwd和shadow文件inode地址，并取出，准备添加条目

	//取出当前目录的inode
	fseek(fr,Cur_Dir_Addr,SEEK_SET);	
	fread(&cur_dir_inode,sizeof(Inode),1,fr);

	//依次取出磁盘块，查找passwd文件的inode地址，和shadow文件的inode地址
	for(i=0;i<10;i++){
		if(cur_dir_inode.i_dirBlock[i]==-1){
			continue;
		}
		//依次取出磁盘块
		fseek(fr,cur_dir_inode.i_dirBlock[i],SEEK_SET);	
		fread(&dirlist,sizeof(dirlist),1,fr);

		for(j=0;j<16;j++){	//遍历目录项
			if( strcmp(dirlist[j].itemName,"passwd")==0 ||	//找到passwd或者shadow条目
				strcmp(dirlist[j].itemName,"shadow")==0 ||
				strcmp(dirlist[j].itemName,"group")==0){
				Inode tmp;	//临时inode
				//取出inode，判断是否是文件
				fseek(fr,dirlist[j].inodeAddr,SEEK_SET);	
				fread(&tmp,sizeof(Inode),1,fr);

				if( ((tmp.i_mode>>9)&1)==0 ){	
					//是文件
					//判别是passwd文件还是shadow文件
					if( strcmp(dirlist[j].itemName,"passwd")==0 ){	
						passwd_Inode_Addr = dirlist[j].inodeAddr;
						passwd_Inode = tmp;
					}
					else if(strcmp(dirlist[j].itemName,"shadow")==0 ){
						shadow_Inode_Addr = dirlist[j].inodeAddr;
						shadow_Inode = tmp;
					}
					else if(strcmp(dirlist[j].itemName,"group")==0 ){
						group_Inode_Addr = dirlist[j].inodeAddr;
						group_Inode = tmp;
					}
				}
			}
		}
		if(passwd_Inode_Addr!=-1 && shadow_Inode_Addr!=-1)	//都找到了
			break;
	}

	//查找passwd文件，看是否存在用户username
	char buf[100000];	//最大100K，暂存passwd的文件内容
	char buf2[600];		//暂存磁盘块内容
	j = 0;	//磁盘块指针
	//取出passwd文件内容
	for(i=0;i<passwd_Inode.i_size;i++){
		if(i%superblock->s_BLOCK_SIZE==0){	//超出了
			//换新的磁盘块
			fseek(fr,passwd_Inode.i_dirBlock[i/superblock->s_BLOCK_SIZE],SEEK_SET);	
			fread(&buf2,superblock->s_BLOCK_SIZE,1,fr);
			j = 0;
		}
		buf[i] = buf2[j++];
	}
	buf[i] = '\0';

	if(strstr(buf,username)!=NULL){
		//没找到该用户
		printf("用户已存在\n");

		//恢复现场，回到原来的目录
		strcpy(Cur_User_Name,bak_Cur_User_Name);
		strcpy(Cur_User_Dir_Name,bak_Cur_User_Dir_Name);
		Cur_Dir_Addr = bak_Cur_Dir_Addr;
		strcpy(Cur_Dir_Name,bak_Cur_Dir_Name);
		return false;
	}
	
	//如果不存在，在passwd中创建新用户条目,修改group文件
	sprintf(buf+strlen(buf),"%s:x:%d:%d\n",username,nextUID++,1);	//增加条目，用户名：加密密码：用户ID：用户组ID。用户组为普通用户组，值为1 
	passwd_Inode.i_size = strlen(buf);
	writefile(passwd_Inode,passwd_Inode_Addr,buf);	//将修改后的passwd写回文件中
	
	//取出shadow文件内容
	j = 0;
	for(i=0;i<shadow_Inode.i_size;i++){
		if(i%superblock->s_BLOCK_SIZE==0){	//超出了这个磁盘块
			//换新的磁盘块
			fseek(fr,shadow_Inode.i_dirBlock[i/superblock->s_BLOCK_SIZE],SEEK_SET);	
			fread(&buf2,superblock->s_BLOCK_SIZE,1,fr);
			j = 0;
		}
		buf[i] = buf2[j++];
	}
	buf[i] = '\0';

	//增加shadow条目
	sprintf(buf+strlen(buf),"%s:%s\n",username,passwd);	//增加条目，用户名：密码
	shadow_Inode.i_size = strlen(buf);
	writefile(shadow_Inode,shadow_Inode_Addr,buf);	//将修改后的内容写回文件中


	//取出group文件内容
	j = 0;
	for(i=0;i<group_Inode.i_size;i++){
		if(i%superblock->s_BLOCK_SIZE==0){	//超出了这个磁盘块
			//换新的磁盘块
			fseek(fr,group_Inode.i_dirBlock[i/superblock->s_BLOCK_SIZE],SEEK_SET);	
			fread(&buf2,superblock->s_BLOCK_SIZE,1,fr);
			j = 0;
		}
		buf[i] = buf2[j++];
	}
	buf[i] = '\0';

	//增加group中普通用户列表
	if(buf[strlen(buf)-2]==':')
		sprintf(buf+strlen(buf)-1,"%s\n",username);	//增加组内用户
	else 
		sprintf(buf+strlen(buf)-1,",%s\n",username);	//增加组内用户
	group_Inode.i_size = strlen(buf);
	writefile(group_Inode,group_Inode_Addr,buf);	//将修改后的内容写回文件中

	//恢复现场，回到原来的目录
	strcpy(Cur_User_Name,bak_Cur_User_Name);
	strcpy(Cur_User_Dir_Name,bak_Cur_User_Dir_Name);
	Cur_Dir_Addr = bak_Cur_Dir_Addr;
	strcpy(Cur_Dir_Name,bak_Cur_Dir_Name);

	printf("用户注册成功\n");
	return true;
}


bool userdel(char username[])	//用户删除
{
	if(strcmp(Cur_User_Name,"root")!=0){
		printf("权限不足:您需要root权限\n");
		return false;
	}
	if(strcmp(username,"root")==0){
		printf("无法删除root用户\n");
		return false;
	}
	int passwd_Inode_Addr = -1;	//用户文件inode地址
	int shadow_Inode_Addr = -1;	//用户密码文件inode地址
	int group_Inode_Addr = -1;	//用户组文件inode地址
	Inode passwd_Inode;		//用户文件的inode
	Inode shadow_Inode;		//用户密码文件的inode
	Inode group_Inode;		//用户组文件inode
	//原来的目录
	char bak_Cur_User_Name[110];
	char bak_Cur_User_Dir_Name[310];
	int bak_Cur_Dir_Addr;
	char bak_Cur_Dir_Name[310];

	Inode cur_dir_inode;	//当前目录的inode
	int i,j;
	DirItem dirlist[16];	//临时目录

	//保存现场，回到根目录
	strcpy(bak_Cur_User_Name,Cur_User_Name);
	strcpy(bak_Cur_User_Dir_Name,Cur_User_Dir_Name);
	bak_Cur_Dir_Addr = Cur_Dir_Addr;
	strcpy(bak_Cur_Dir_Name,Cur_Dir_Name);

	//回到根目录
	gotoRoot();

	//进入用户目录
	cd(Cur_Dir_Addr,"etc");

	//输入用户密码
	//char passwd[100] = {0};
	//inPasswd(passwd);	//输入密码

	//找到passwd和shadow文件inode地址，并取出，准备添加条目

	//取出当前目录的inode
	fseek(fr,Cur_Dir_Addr,SEEK_SET);	
	fread(&cur_dir_inode,sizeof(Inode),1,fr);

	//依次取出磁盘块，查找passwd文件的inode地址，和shadow文件的inode地址
	for(i=0;i<10;i++){
		if(cur_dir_inode.i_dirBlock[i]==-1){
			continue;
		}
		//依次取出磁盘块
		fseek(fr,cur_dir_inode.i_dirBlock[i],SEEK_SET);	
		fread(&dirlist,sizeof(dirlist),1,fr);

		for(j=0;j<16;j++){	//遍历目录项
			if( strcmp(dirlist[j].itemName,"passwd")==0 ||	//找到passwd或者shadow条目
				strcmp(dirlist[j].itemName,"shadow")==0 ||
				strcmp(dirlist[j].itemName,"group")==0){
				Inode tmp;	//临时inode
				//取出inode，判断是否是文件
				fseek(fr,dirlist[j].inodeAddr,SEEK_SET);	
				fread(&tmp,sizeof(Inode),1,fr);

				if( ((tmp.i_mode>>9)&1)==0 ){	
					//是文件
					//判别是passwd文件还是shadow文件
					if( strcmp(dirlist[j].itemName,"passwd")==0 ){	
						passwd_Inode_Addr = dirlist[j].inodeAddr;
						passwd_Inode = tmp;
					}
					else if(strcmp(dirlist[j].itemName,"shadow")==0 ){
						shadow_Inode_Addr = dirlist[j].inodeAddr;
						shadow_Inode = tmp;
					}
					else if(strcmp(dirlist[j].itemName,"group")==0 ){
						group_Inode_Addr = dirlist[j].inodeAddr;
						group_Inode = tmp;
					}
				}
			}
		}
		if(passwd_Inode_Addr!=-1 && shadow_Inode_Addr!=-1)	//都找到了
			break;
	}

	//查找passwd文件，看是否存在用户username
	char buf[100000];	//最大100K，暂存passwd的文件内容
	char buf2[600];		//暂存磁盘块内容
	j = 0;	//磁盘块指针
	//取出passwd文件内容
	for(i=0;i<passwd_Inode.i_size;i++){
		if(i%superblock->s_BLOCK_SIZE==0){	//超出了
			//换新的磁盘块
			fseek(fr,passwd_Inode.i_dirBlock[i/superblock->s_BLOCK_SIZE],SEEK_SET);	
			fread(&buf2,superblock->s_BLOCK_SIZE,1,fr);
			j = 0;
		}
		buf[i] = buf2[j++];
	}
	buf[i] = '\0';

	if(strstr(buf,username)==NULL){
		//没找到该用户
		printf("用户不存在\n");

		//恢复现场，回到原来的目录
		strcpy(Cur_User_Name,bak_Cur_User_Name);
		strcpy(Cur_User_Dir_Name,bak_Cur_User_Dir_Name);
		Cur_Dir_Addr = bak_Cur_Dir_Addr;
		strcpy(Cur_Dir_Name,bak_Cur_Dir_Name);
		return false;
	}
	
	//如果存在，在passwd、shadow、group中删除该用户的条目
	//删除passwd条目
	char *p = strstr(buf,username);
	*p = '\0';
	while((*p)!='\n')	//空出中间的部分
		p++;
	p++;
	strcat(buf,p);	
	passwd_Inode.i_size = strlen(buf);	//更新文件大小
	writefile(passwd_Inode,passwd_Inode_Addr,buf);	//将修改后的passwd写回文件中
	
	//取出shadow文件内容
	j = 0;
	for(i=0;i<shadow_Inode.i_size;i++){
		if(i%superblock->s_BLOCK_SIZE==0){	//超出了这个磁盘块
			//换新的磁盘块
			fseek(fr,shadow_Inode.i_dirBlock[i/superblock->s_BLOCK_SIZE],SEEK_SET);	
			fread(&buf2,superblock->s_BLOCK_SIZE,1,fr);
			j = 0;
		}
		buf[i] = buf2[j++];
	}
	buf[i] = '\0';

	//删除shadow条目
	p = strstr(buf,username);
	*p = '\0';
	while((*p)!='\n')	//空出中间的部分
		p++;
	p++;
	strcat(buf,p);	
	shadow_Inode.i_size = strlen(buf);	//更新文件大小
	writefile(shadow_Inode,shadow_Inode_Addr,buf);	//将修改后的内容写回文件中


	//取出group文件内容
	j = 0;
	for(i=0;i<group_Inode.i_size;i++){
		if(i%superblock->s_BLOCK_SIZE==0){	//超出了这个磁盘块
			//换新的磁盘块
			fseek(fr,group_Inode.i_dirBlock[i/superblock->s_BLOCK_SIZE],SEEK_SET);	
			fread(&buf2,superblock->s_BLOCK_SIZE,1,fr);
			j = 0;
		}
		buf[i] = buf2[j++];
	}
	buf[i] = '\0';

	//增加group中普通用户列表
	p = strstr(buf,username);
	*p = '\0';
	while((*p)!='\n' && (*p)!=',')	//空出中间的部分
		p++;
	if((*p)==',')
		p++;
	strcat(buf,p);	
	group_Inode.i_size = strlen(buf);	//更新文件大小
	writefile(group_Inode,group_Inode_Addr,buf);	//将修改后的内容写回文件中

	//恢复现场，回到原来的目录
	strcpy(Cur_User_Name,bak_Cur_User_Name);
	strcpy(Cur_User_Dir_Name,bak_Cur_User_Dir_Name);
	Cur_Dir_Addr = bak_Cur_Dir_Addr;
	strcpy(Cur_Dir_Name,bak_Cur_Dir_Name);

	//删除用户目录	
	Cur_Dir_Addr = Root_Dir_Addr;	//当前用户目录地址设为根目录地址
	strcpy(Cur_Dir_Name,"/");		//当前目录设为"/"
	cd(Cur_Dir_Addr,"home");
	rmdir(Cur_Dir_Addr,username);

	//恢复现场，回到原来的目录
	strcpy(Cur_User_Name,bak_Cur_User_Name);
	strcpy(Cur_User_Dir_Name,bak_Cur_User_Dir_Name);
	Cur_Dir_Addr = bak_Cur_Dir_Addr;
	strcpy(Cur_Dir_Name,bak_Cur_Dir_Name);

	printf("用户已删除\n");
	return true;
	
}

void chmod(int parinoAddr,char name[],int pmode)	//修改文件或目录权限//文件名称以及pmode
{
	if(strlen(name)>=MAX_NAME_SIZE){
		printf("超过最大目录名长度\n");
		return ;
	}
	if(strcmp(name,".")==0 || strcmp(name,"..")==0){
		printf("错误操作\n");
		return ;
	}
	//取出该文件或目录inode
	Inode cur,fileInode;
	fseek(fr,parinoAddr,SEEK_SET);//将文件指针移动到该目录的inode
	fread(&cur,sizeof(Inode),1,fr);//读取该目录的inode

	//依次取出磁盘块
	int i = 0,j;
	DirItem dirlist[16] = {0};
	while(i<160){
		if(cur.i_dirBlock[i/16]==-1){
			i+=16;
			continue;
		}
		//取出磁盘块
		int parblockAddr = cur.i_dirBlock[i/16];
		fseek(fr,parblockAddr,SEEK_SET);	
		fread(&dirlist,sizeof(dirlist),1,fr);
		fflush(fr);

		//输出该磁盘块中的所有目录项
		for(j=0;j<16;j++){
			if( strcmp(dirlist[j].itemName,name)==0 ){	//找到该目录或者文件
				//取出对应的inode
				fseek(fr,dirlist[j].inodeAddr,SEEK_SET);//将文件指针移动到该目录的inode	
				fread(&fileInode,sizeof(Inode),1,fr);//读取该目录的inode
				fflush(fr);
				goto label;
			}
		}
		i++;
	}
label:
	if(i>=160){
		printf("文件不存在\n");
		return ;
	}
	//判断是否是本用户或者是一个管理员的权限
	if(strcmp(Cur_User_Name,fileInode.i_uname)!=0 && strcmp(Cur_User_Name,"root")!=0){
		printf("权限不足\n");
		return ;
	}

	//对inode的mode属性进行修改
	fileInode.i_mode  = (fileInode.i_mode>>9<<9) | pmode;	//修改权限

	//将inode写回磁盘
	fseek(fw,dirlist[j].inodeAddr,SEEK_SET);	//将文件指针移动到该目录的inode
	fwrite(&fileInode,sizeof(Inode),1,fw);//读取该目录的inode
	fflush(fw);//刷新缓冲区
}

void touch(int parinoAddr,char name[],char buf[])	//touch命令创建文件，读入字符
{
	//先判断文件是否已存在。如果存在，打开这个文件并编辑
	if(strlen(name)>=MAX_NAME_SIZE){
		printf("超过最大文件名长度\n");
		return ;
	}
	//查找有无同名文件，有的话提示错误，退出程序。没有的话，创建一个空文件
	DirItem dirlist[16];	//临时目录清单

	//从这个地址取出inode
	Inode cur,fileInode;
	fseek(fr,parinoAddr,SEEK_SET);	
	fread(&cur,sizeof(Inode),1,fr);

	//判断文件模式。6为owner，3为group，0为other
	int filemode;
	if(strcmp(Cur_User_Name,cur.i_uname)==0 ) 
		filemode = 6;
	else if(strcmp(Cur_User_Name,cur.i_gname)==0)
		filemode = 3;
	else 
		filemode = 0;
	
	int i = 0,j;
	int dno;
	int fileInodeAddr = -1;	//文件的inode地址
	while(i<160){
		//160个目录项之内，可以直接在直接块里找
		dno = i/16;	//在第几个直接块里

		if(cur.i_dirBlock[dno]==-1){
			i+=16;
			continue;
		}
		fseek(fr,cur.i_dirBlock[dno],SEEK_SET);	
		fread(dirlist,sizeof(dirlist),1,fr);
		fflush(fr);

		//输出该磁盘块中的所有目录项
		for(j=0;j<16;j++){
			if(strcmp(dirlist[j].itemName,name)==0 ){
				//重名，取出inode，判断是否是文件
				fseek(fr,dirlist[j].inodeAddr,SEEK_SET);	
				fread(&fileInode,sizeof(Inode),1,fr);
				if( ((fileInode.i_mode>>9)&1)==0 ){	//是文件且重名，提示错误，退出程序
					printf("文件已存在\n");
					return ;
				}
			}
			i++;
		}
	}

	//文件不存在，创建一个空文件
	if( ((cur.i_mode>>filemode>>1)&1)==1){
		//可写。可以创建文件
		buf[0] = '\0';
		create(parinoAddr,name,buf);	//创建文件
	}
	else{
		printf("权限不足：无写入权限\n");
		return ;
	}
	
}

void help()	//显示所有命令清单 
{
	printf("ls - 显示当前目录清单\n");
	printf("cd - 进入目录\n");
	printf("mkdir - 创建目录\n");
	printf("rmdir - 删除目录\n");
	printf("super - 查看超级块\n");
	printf("inode - 查看inode位图\n");
	printf("block - 查看block位图\n");
	printf("vi - vi编辑器\n");
	printf("touch - 创建一个空文件\n");
	printf("rm - 删除文件\n");
	printf("cls - 清屏\n");
	printf("create - 创建文件\n");
	printf("logout - 用户注销\n");
	printf("useradd - 添加用户\n");
	printf("userdel - 删除用户\n");
	printf("chmod - 修改文件或目录权限\n");
	printf("help - 显示命令清单\n");
	printf("exit - 退出系统\n");
	return ;
}

void cmd(char str[])	//处理输入的命令
{
	char p1[100];
	char p2[100];
	char p3[100];
	char buf[100000];	//最大100K
	int tmp = 0;
	int i;
	sscanf(str,"%s",p1);//L先读取str的第一个字符串
	if(strcmp(p1,"ls")==0){//L判断是否显示当前目录
		ls(Cur_Dir_Addr);	//显示当前目录
	}
	else if(strcmp(p1,"cd")==0){//L判断是否进入目录
		sscanf(str,"%s%s",p1,p2);//L读取str的第二个字符串
		cd(Cur_Dir_Addr,p2);	
	}
	else if(strcmp(p1,"mkdir")==0){//L判断是否创建目录
		sscanf(str,"%s%s",p1,p2);//L读取str的第二个字符串
		mkdir(Cur_Dir_Addr,p2);	//L在当前的目录下创建目录
	}
	else if(strcmp(p1,"rmdir")==0){//L判断是否删除目录
		sscanf(str,"%s%s",p1,p2);
		rmdir(Cur_Dir_Addr,p2);	//L在当前的目录下删除目录
	}
	else if(strcmp(p1,"super")==0){//L判断是否显示超级块
		printSuperBlock();//L显示超级块
	}
	else if(strcmp(p1,"inode")==0){//L判断是否显示inode位图
		printInodeBitmap();
	}
	else if(strcmp(p1,"block")==0){//L判断是否显示block位图
		sscanf(str,"%s%s",p1,p2);
		tmp = 0;
		if('0'<=p2[0] && p2[0]<='9'){
			tmp=atoi(p2);
			// for(i=0;p2[i];i++)
			// 	tmp = tmp*10+p2[i]-'0';
			printBlockBitmap(tmp);
		}
		else
			printBlockBitmap();
	}
	else if(strcmp(p1,"vi")==0){	//创建一个文件
		sscanf(str,"%s%s",p1,p2);
		vi(Cur_Dir_Addr,p2,buf);	//读取内容到buf
	}
	else if(strcmp(p1,"touch")==0){
		sscanf(str,"%s%s",p1,p2);
		touch (Cur_Dir_Addr,p2,buf);	//读取内容到buf
	}
	else if(strcmp(p1,"rm")==0){	//删除一个文件
		sscanf(str,"%s%s",p1,p2);
		del(Cur_Dir_Addr,p2);
	}
	else if(strcmp(p1,"cls")==0){//L简单的清屏命令
		system("cls");
	}
	else if(strcmp(p1,"logout")==0){//L用户注销,退出登陆
		logout();
	}
	else if(strcmp(p1,"useradd")==0){//L新增用户
		p2[0] = '\0';
		sscanf(str,"%s%s",p1,p2);
		if(strlen(p2)==0){
			printf("参数错误\n");
		}
		else{
			useradd(p2);
		}
	}
	else if(strcmp(p1,"userdel")==0){//L删除用户
		p2[0] = '\0';
		sscanf(str,"%s%s",p1,p2);
		if(strlen(p2)==0){
			printf("参数错误\n");
		}
		else{
			userdel(p2);
		}
	}
	else if(strcmp(p1,"chmod")==0){//L修改文件或目录权限
		p2[0] = '\0';
		p3[0] = '\0';
		sscanf(str,"%s%s%s",p1,p2,p3);
		if(strlen(p2)==0 || strlen(p3)==0){
			printf("参数错误\n");
		}
		else{
			tmp = 0;
			for(i=0;p3[i];i++)
				tmp = tmp*8+p3[i]-'0';
			chmod(Cur_Dir_Addr,p2,tmp);
		}
	}
	else if(strcmp(p1,"help")==0){//L显示帮助信息
		help();
	}
	else if(strcmp(p1,"format")==0){//L格式化磁盘
		if(strcmp(Cur_User_Name,"root")!=0){
			printf("权限不足：您需要root权限\n");
			return ;
		}
		Ready();
		logout();
	}
	else if(strcmp(p1,"exit")==0){
		printf("退出MingOS\n");
		exit(0);
	}
	else if(strcmp(p1,"create")==0){
		p2[0] = '\0';
		sscanf(str,"%s%s%s",p1,p2,p3);
		create(Cur_Dir_Addr,p2,p3);
	}
	else{
		printf("抱歉，没有该命令\n");
	}
	return ;
}
